# Chapter 4. The `class` File Format

# 第4章. class文件格式 - JVM规范文档

This chapter describes the `class` file format of the Java Virtual Machine. Each `class` file contains the definition of a single class or interface. Although a class or interface need not have an external representation literally contained in a file (for instance, because the class is generated by a class loader), we will colloquially refer to any valid representation of a class or interface as being in the `class` file format.

本章主要介绍Java虚拟机规范中的 `class` 文件格式。每个 `class` 文件只包含一个类(class)或接口(interface)的定义. 虽然有些类不需要有对应的物理文件存在(由 class loader 动态生成的), 但为了表述方便, 统一把 class/interface 的有效表示形式称为 `class` 文件格式。


A `class` file consists of a stream of 8-bit bytes. All 16-bit, 32-bit, and 64-bit quantities are constructed by reading in two, four, and eight consecutive 8-bit bytes, respectively. Multibyte data items are always stored in big-endian order, where the high bytes come first. In the Java SE platform, this format is supported by interfaces `java.io.DataInput` and `java.io.DataOutput` and classes such as `java.io.DataInputStream` and `java.io.DataOutputStream`.


`class` 文件由8位的字节流组成(8-bit bytes)。所有的16位、32位和64位数据, 都由连续的2个,4个,8个字节组合而成. 多个字节组成的数据项, 统一存储为大端字节序(big-endian order), 即高位字节放在前面。在Java中, 这种格式的标准读写接口是 `java.io.DataInput` 和 `java.io.DataOutput`; 对应的实现类包括 `java.io.DataInputStream` 和 `java.io.DataOutputStream` 等。

> **备注**: 大端字节序(big-endian order): 比如数值 `454355811`, 表述为二进制就是 `00011011 00010100 11101011 01100011`; 对应的16进制为 `1B14EB63`, 也可以加上 `0x`的前缀 `0x1B14EB63`;
>
> 从前到后的字节流是: `| 1B | 14 | EB | 63 |`。
>
> 小端字节序, 从前到后的字节流就是: `| 63 | EB | 14 | 1B |`。
>
> 可以看到、小端字节序并不太方便我们直接理解。
>



This chapter defines its own set of data types representing `class` file data: The types `u1`, `u2`, and `u4` represent an unsigned one-, two-, or four-byte quantity, respectively. In the Java SE platform, these types may be read by methods such as `readUnsignedByte`, `readUnsignedShort`, and `readInt` of the interface `java.io.DataInput`.


本章中, `class` 文件定义的数据类型包括: `u1`, `u2`, 和 `u4`, 分别表示无符号的(unsigned) 1字节、2字节和4字节数据. 在Java中, 可通过 `java.io.DataInput` 接口中的 `readUnsignedByte()`, `readUnsignedShort()`, 以及 `readInt()` 方法来读取。

> "quantity", 本文大部分翻译为 "数据";


This chapter presents the `class` file format using pseudostructures written in a C-like structure notation. To avoid confusion with the fields of classes and class instances, etc., the contents of the structures describing the `class` file format are referred to as *items*. Successive items are stored in the `class` file sequentially, without padding or alignment.


本章使用类C语言的伪结构体(pseudo-structures)来表示 `class` 文件格式。为了区别 field(属性域) 和 instance(类实例), `class` 文件对应结构体中的内容称为 **items**(数据项)。 这些item按顺序保存在 `class` 文件中, 没有补齐(padding), 也没有对齐(alignment)。


*Tables*, consisting of zero or more variable-sized items, are used in several `class` file structures. Although we use C-like array syntax to refer to table items, the fact that tables are streams of varying-sized structures means that it is not possible to translate a table index directly to a byte offset into the table.

**Tables**(列表), 由0到多个大小可变的item组成, 被多个结构体所使用. 虽然我们使用类似数组下标的方式来指向 table 中的 item, 但实际上 table 应该算是一个 List, 由多个不同大小的结构体所组成, 也就是说, 不能通过下标乘以某个数字直接计算出在class文件中的偏移量。


Where we refer to a data structure as an *array*, it consists of zero or more contiguous fixed-sized items and can be indexed like an array.

而如果使用 **array**(数组)结构, 则表示其中包含0到多个, 连续的, 固定长度的 item, 可以通过数组下标的方式直接计算出偏移量。


Reference to an ASCII character in this chapter should be interpreted to mean the Unicode code point corresponding to the ASCII character.


本章所引用的每一个ASCII字符, 都应该解释为对应字符的Unicode编码。



原文链接: <https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html>



